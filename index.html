<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR 圣诞树 - 像素复刻版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        /* 视频框放在右下角，方便对比 */
        #video-input {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            z-index: 2;
            opacity: 0.8;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 20px; z-index: 10; pointer-events: none; text-align: center;
            text-shadow: 0 0 10px rgba(0,255,0,0.5);
        }
        #title-text {
            position: absolute;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: 'Times New Roman', serif;
            font-size: 40px;
            font-weight: bold;
            z-index: 0; /* 在 Canvas 后面 */
            opacity: 0; /* 默认隐藏，握拳显示 */
            transition: opacity 1s;
            text-shadow: 0 0 10px #fff;
        }
    </style>
    
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/stats.js@0.17.0/build/stats.min.js"></script>
</head>
<body>
    <div id="loading">正在准备礼物...<br><span style="font-size:14px; opacity:0.7">请允许摄像头权限</span></div>
    <div id="title-text">新年快乐 my love</div>
    
    <!-- 背景音乐 -->
    <audio id="bgm" loop>
        <source src="assets/bgm.mp3" type="audio/mpeg">
    </audio>
    
    <!-- 调试面板 -->
    <button id="cam-toggle" style="position: absolute; top: 10px; right: 10px; z-index: 100; padding: 8px 15px; background: rgba(0,255,0,0.3); border: 1px solid white; color: white; border-radius: 20px; cursor: pointer;">
        ▶ 启动摄像头
    </button>
    <div id="debug-panel" style="position: absolute; top: 10px; left: 10px; color: #0f0; font-family: monospace; font-size: 12px; z-index: 100; background: rgba(0,0,0,0.5); padding: 5px; pointer-events: none; display: none;">
        <div>FPS: <span id="debug-fps">0</span></div>
        <div>State: <span id="debug-state">INIT</span></div>
        <div>Raw: <span id="debug-raw">INIT</span></div>
        <div>Fingers: <span id="debug-fingers">0</span></div>
        <div>Lock: <span id="debug-lock">0</span>ms</div>
    </div>

    <video id="video-input"></video>
    <div id="canvas-container"></div>

    <script>
        // ==========================================
        // 性能监控
        // ==========================================
        let stats;
        try {
            if (typeof Stats !== 'undefined') {
                stats = new Stats();
                stats.showPanel(0); // 0: fps, 1: ms
                stats.dom.style.position = 'absolute';
                stats.dom.style.top = '0px';
                stats.dom.style.left = '0px';
                stats.dom.style.display = 'none'; // 默认隐藏
                document.body.appendChild(stats.dom);
            }
        } catch (e) {
            console.warn("Stats.js failed to load", e);
        }

        // 显示调试信息开关
        const DEBUG_MODE = true;
        if (DEBUG_MODE) {
            document.getElementById('debug-panel').style.display = 'block';
            // if (stats) stats.dom.style.display = 'block';
        }

        // ==========================================
        // 全局配置 (复刻版)
        // ==========================================
        const CONFIG = {
            particleCount: 5000, // 优化：减少粒子数量以提升流畅度 (原 8000)
            baseSize: 3.5,       
            camZ: 100,
            colors: {
                treeGreen: [0.18, 0.8, 0.44],  // #2ecc71
                treeDark: [0.15, 0.68, 0.38],  // #27ae60
                trunkPink: [1.0, 0.41, 0.71],  // #ff69b4 HotPink
                starYellow: [0.95, 0.77, 0.06], // #f1c40f
                snowWhite: [1.0, 1.0, 1.0]
            }
        };

        const STATE = {
            gesture: 'open', // open | fist | pinch
            handPos: new THREE.Vector3(0, 0, 0),
            targetHandPos: new THREE.Vector3(0, 0, 0), // 新增：用于平滑手势位置
            targetScale: 1.0,
            currentScale: 1.0,
            gestureHistory: {
                last: 'open',
                count: 0,
                confirmThreshold: 1 // 极致响应：从 2 降为 1，即时切换
            },
            lastSwitchTime: 0, 
            lockDuration: 0, // 移除锁定时间，允许快速连续切换
            
            // 相机控制系统
            camera: {
                targetPos: new THREE.Vector3(0, 0, CONFIG.camZ), // 目标位置
                currentPos: new THREE.Vector3(0, 0, CONFIG.camZ), // 当前位置
                targetLookAt: new THREE.Vector3(0, 0, 0), // 目标焦点
                currentLookAt: new THREE.Vector3(0, 0, 0), // 当前焦点
                isZooming: false
            },
            
            // 照片索引
            focusPhotoIdx: 0
        };

        // ==========================================
        // Three.js 初始化
        // ==========================================
        const scene = new THREE.Scene();
        // 稍微有点雾，增加氛围
        scene.fog = new THREE.FogExp2(0x000000, 0.005);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.camZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // ==========================================
        // 粒子系统构建 (精致版)
        // ==========================================
        const geometry = new THREE.BufferGeometry();
        const posArray = new Float32Array(CONFIG.particleCount * 3);
        const colArray = new Float32Array(CONFIG.particleCount * 3);
        const sizeArray = new Float32Array(CONFIG.particleCount); 
        const phaseArray = new Float32Array(CONFIG.particleCount); // 闪烁相位
        
        // 目标位置
        let targetPosArray = new Float32Array(CONFIG.particleCount * 3);
        let currentPosArray = new Float32Array(CONFIG.particleCount * 3);
        let targetColArray = new Float32Array(CONFIG.particleCount * 3);
        let currentColArray = new Float32Array(CONFIG.particleCount * 3);

        for(let i=0; i<CONFIG.particleCount; i++) {
            // ... (位置初始化逻辑保持不变，略)
            const x = (Math.random() - 0.5) * 300;
            const y = (Math.random() - 0.5) * 200;
            const z = (Math.random() - 0.5) * 100;
            
            currentPosArray[i*3] = x; currentPosArray[i*3+1] = y; currentPosArray[i*3+2] = z;
            targetPosArray[i*3] = x; targetPosArray[i*3+1] = y; targetPosArray[i*3+2] = z;

            const r = 0.8 + Math.random()*0.2;
            const g = 1.0;
            const b = 1.0;
            currentColArray[i*3] = r; currentColArray[i*3+1] = g; currentColArray[i*3+2] = b;
            targetColArray[i*3] = r; targetColArray[i*3+1] = g; targetColArray[i*3+2] = b;

            // 尺寸多样性：大部分是小的背景粒子，少部分是大的高光粒子
            if (Math.random() > 0.8) {
                sizeArray[i] = CONFIG.baseSize * (1.2 + Math.random()); // 大粒子
            } else {
                sizeArray[i] = CONFIG.baseSize * (0.6 + Math.random() * 0.4); // 小粒子
            }
            
            // 随机相位，用于闪烁动画
            phaseArray[i] = Math.random() * Math.PI * 2;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(currentPosArray, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(currentColArray, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));
        geometry.setAttribute('phase', new THREE.BufferAttribute(phaseArray, 1)); // 自定义属性

        // 升级版材质：使用高质量纹理
        const material = new THREE.PointsMaterial({
            size: CONFIG.baseSize,
            vertexColors: true,
            map: createCrystalTexture(), // 晶体质感纹理
            transparent: true,
            opacity: 1.0, 
            depthWrite: false,
            // 混合模式：默认混合比 Additive 更清晰，不容易过曝
            blending: THREE.NormalBlending 
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        const snowCount = 1000;
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = new Float32Array(snowCount * 3);
        for(let i=0; i<snowCount; i++) {
            snowPos[i*3] = (Math.random()-0.5)*300;
            snowPos[i*3+1] = (Math.random()-0.5)*300;
            snowPos[i*3+2] = (Math.random()-0.5)*100;
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));

        const snowMat = new THREE.PointsMaterial({
            color: 0xffffff, 
            size: 3.0, 
            map: createCrystalTexture(), 
            transparent: true, 
            opacity: 0.6,
            depthWrite: false
        });
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);
        
        // 创建一个晶体感/散焦光斑纹理 (高清版)
        function createCrystalTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256; // 提高分辨率到 256x256
            const ctx = canvas.getContext('2d');
            
            const cx = 128;
            const cy = 128;
            
            // 1. 核心高亮区 (更小更亮，像钻石中心)
            ctx.beginPath();
            ctx.arc(cx, cy, 20, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(255, 255, 255, 1)";
            ctx.shadowBlur = 10;
            ctx.shadowColor = "white";
            ctx.fill();
            ctx.shadowBlur = 0; // 重置
            
            // 2. 内部辉光 (多层渐变，模拟光晕)
            const gradient = ctx.createRadialGradient(cx, cy, 20, cx, cy, 120);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            
            // 3. 星芒 (8角星，更细腻)
            ctx.globalAlpha = 0.8;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            
            const drawStar = (radius, alpha) => {
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.moveTo(cx - radius, cy); ctx.lineTo(cx + radius, cy);
                ctx.moveTo(cx, cy - radius); ctx.lineTo(cx, cy + radius);
                ctx.stroke();
                
                // 对角线小芒
                ctx.beginPath();
                const r2 = radius * 0.6;
                ctx.moveTo(cx - r2 * 0.7, cy - r2 * 0.7); ctx.lineTo(cx + r2 * 0.7, cy + r2 * 0.7);
                ctx.moveTo(cx + r2 * 0.7, cy - r2 * 0.7); ctx.lineTo(cx - r2 * 0.7, cy + r2 * 0.7);
                ctx.stroke();
            };
            
            drawStar(80, 0.6); // 大芒
            
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            return tex;
        }

        // ==========================================
        // 照片对象 (The Romantic Reveal)
        // ==========================================
        // 生成默认占位图 (爱心画) - 高清版
        function createPhotoTexture(text = "My Love", themeColor = "#ff6b6b") {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1360; // 提高分辨率 2x
            const ctx = canvas.getContext('2d');
            
            // 白底照片纸
            ctx.fillStyle = '#fdfdfd';
            ctx.fillRect(0, 0, 1024, 1360);
            
            // 照片区域
            ctx.fillStyle = '#333';
            ctx.fillRect(80, 80, 864, 864);
            
            // 画个爱心
            ctx.fillStyle = themeColor;
            ctx.beginPath();
            const s = 30; // scale 2x
            const ox = 512; // center x
            const oy = 512; // center y
            ctx.moveTo(ox, oy + 10 * s);
            ctx.bezierCurveTo(ox - 10 * s, oy - 5 * s, ox - 15 * s, oy - 15 * s, ox, oy - 15 * s);
            ctx.bezierCurveTo(ox + 15 * s, oy - 15 * s, ox + 10 * s, oy - 5 * s, ox, oy + 10 * s);
            ctx.fill();
            
            // 文字
            ctx.fillStyle = '#333';
            ctx.font = 'italic 80px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, 512, 1160);
            
            const tex = new THREE.Texture(canvas);
            tex.needsUpdate = true;
            tex.minFilter = THREE.LinearFilter; // 确保缩小时也平滑
            return tex;
        }
        
        // 初始化照片库
        // ======================================================
        // 【自定义照片指南】
        // 1. 将您的照片（.jpg 或 .png）放入项目根目录下的 assets 文件夹中
        // 2. 在下方的 userPhotos 数组中填入文件名
        // 3. 如果文件加载失败，系统会自动回退到默认的爱心绘图
        // ======================================================
        
        const userPhotos = [
            "assets/photo1.jpg",
            "assets/photo2.jpg",
            "assets/photo3.jpg", 
            "assets/photo4.jpg"
            // 在这里添加您的照片路径...
        ];

        const defaultThemes = [
            { text: "My Love", color: "#ff6b6b" },
            { text: "For You", color: "#4facfe" },
            { text: "2025",    color: "#f093fb" },
            { text: "Forever", color: "#fa709a" },
            { text: "Happy",   color: "#43e97b" }
        ];
        
        const textureLoader = new THREE.TextureLoader();
        let photoTextures = [];

        // 统一加载函数
        function initTextures() {
            if (userPhotos.length > 0) {
                photoTextures = userPhotos.map(url => {
                    return textureLoader.load(url, undefined, undefined, (err) => {
                        console.warn("Failed to load photo:", url);
                    });
                });
            } else {
                photoTextures = defaultThemes.map(d => createPhotoTexture(d.text, d.color));
            }
        }
        initTextures();

        // === 分布式照片画廊 (Distributed Photo Gallery) ===
         const photoMeshes = [];
         const GALLERY_SIZE = 4; // 改回 4 张
         
         // 随机散布生成器 (确保在视野内)
         function getRandomPos() {
             return {
                 x: (Math.random() - 0.5) * 180, // 宽范围
                 y: (Math.random() - 0.5) * 100, // 高范围
                 z: (Math.random() - 0.5) * 50   // 深度范围
             };
         }

         // 创建所有照片对象
         function initPhotoGallery() {
             // 清理旧对象
             photoMeshes.forEach(m => scene.remove(m));
             photoMeshes.length = 0;

             // 循环生成
             for(let i=0; i<GALLERY_SIZE; i++) {
                 // 随机取一张纹理
                 const texIdx = i % photoTextures.length;
                 const tex = photoTextures[texIdx];
                 
                 // 默认尺寸
                 const geo = new THREE.PlaneGeometry(36, 48); 
                 
                 // 自适应宽高
                 if (tex && tex.image && tex.image.width) {
                     const aspect = tex.image.width / tex.image.height;
                     const newH = 48;
                     const newW = 48 * aspect;
                     geo.dispose();
                     geo.copy(new THREE.PlaneGeometry(newW, newH));
                 }
                 
                 const mat = new THREE.MeshBasicMaterial({ 
                     map: tex,
                     transparent: true,
                     opacity: 0.8, // 稍微透明，融入背景
                     side: THREE.DoubleSide,
                     depthTest: false, // 仍然需要可见，但可以稍微融合
                     blending: THREE.AdditiveBlending // 关键：使用叠加混合，让照片看起来像发光的粒子
                 });
                 const mesh = new THREE.Mesh(geo, mat);
                 
                 // === 关键修改：绑定到宿主粒子 ===
                 // 我们随机选一个粒子作为宿主 (Host Particle)
                 // 为了分布均匀，我们选索引间隔较大的粒子
                 const hostParticleIdx = Math.floor(i * (CONFIG.particleCount / GALLERY_SIZE)) + Math.floor(Math.random() * 100);
                 mesh.userData.hostIdx = hostParticleIdx;
                 
                 // 初始状态：先设一个暂时的 Home Pos，稍后在 animate 中实时更新
                 mesh.userData.homePos = new THREE.Vector3(0,0,0);
                 
                 // 2. 设定原始混乱旋转
                 mesh.userData.homeRot = new THREE.Euler(
                     (Math.random()-0.5), 
                     (Math.random()-0.5), 
                     (Math.random()-0.5)
                 );
                 
                 mesh.rotation.copy(mesh.userData.homeRot);
                 mesh.scale.setScalar(0.15); 
                 
                 mesh.visible = true; 
                 mesh.renderOrder = 999; 
                 
                 scene.add(mesh);
                 photoMeshes.push(mesh);
             }
         }
         
         // 延迟初始化，确保纹理加载开始
         setTimeout(initPhotoGallery, 500);

         // ==========================================
         // 形状生成器
         // ==========================================
        const Shapes = {
            // 散开形态
            open: () => {
                const p = new Float32Array(CONFIG.particleCount * 3);
                const c = new Float32Array(CONFIG.particleCount * 3);
                for(let i=0; i<CONFIG.particleCount; i++) {
                    // 宽阔的云雾
                    p[i*3] = (Math.random()-0.5) * 350;
                    p[i*3+1] = (Math.random()-0.5) * 250;
                    p[i*3+2] = (Math.random()-0.5) * 150;
                    
                    // 青白色
                    c[i*3] = 0.8; c[i*3+1] = 1.0; c[i*3+2] = 1.0;
                }
                return { pos: p, col: c };
            },

            // 圣诞树形态 (2D 像素风 -> 3D 精致分层版)
            tree: () => {
                const p = new Float32Array(CONFIG.particleCount * 3);
                const c = new Float32Array(CONFIG.particleCount * 3);
                
                // 树的整体参数
                const totalHeight = 65; 
                const maxRadius = 25;
                const trunkW = 6;
                const trunkH = 15;
                
                // 颜色库
                const colors = {
                    leafDark: [0.05, 0.4, 0.15], // 深绿
                    leafLight: [0.2, 0.8, 0.3], // 嫩绿
                    gold: [1.0, 0.84, 0.0],
                    red: [0.9, 0.1, 0.1],
                    blue: [0.2, 0.4, 0.9],
                    warmWhite: [1.0, 0.95, 0.8]
                };

                let idx = 0;

                // 1. 树顶星 (Top Star) - 占用前 50 个粒子做一颗大星星
                const starSize = 50;
                for(let i=0; i<starSize; i++) {
                    // 星星中心
                    const y = totalHeight / 2; 
                    // 放射状
                    const r = Math.random() * 4;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    
                    p[idx*3] = r * Math.sin(phi) * Math.cos(theta);
                    p[idx*3+1] = y + r * Math.sin(phi) * Math.sin(theta);
                    p[idx*3+2] = r * Math.cos(phi);
                    
                    // 亮黄色
                    c[idx*3] = 1.0; c[idx*3+1] = 1.0; c[idx*3+2] = 0.5;
                    idx++;
                }

                // 2. 树干 (Trunk) - 约 10%
                const trunkCount = Math.floor(CONFIG.particleCount * 0.1);
                for(let i=0; i<trunkCount; i++) {
                    const r = (Math.random() - 0.5) * trunkW;
                    const h = (Math.random() - 0.5) * trunkH - (totalHeight/2 + trunkH/2);
                    const d = (Math.random() - 0.5) * trunkW;
                    
                    p[idx*3] = r; p[idx*3+1] = h; p[idx*3+2] = d;
                    // 棕色
                    c[idx*3] = 0.4; c[idx*3+1] = 0.2; c[idx*3+2] = 0.1;
                    idx++;
                }

                // 3. 分层树冠 (Layered Crown)
                // 模拟松树的 4 层结构
                const layers = 4;
                const particlesPerLayer = Math.floor((CONFIG.particleCount - idx) / layers);
                
                for(let l=0; l<layers; l++) {
                    // 每层参数
                    const layerProgress = l / (layers - 1); // 0(底) -> 1(顶)
                    const layerY = -totalHeight/2 + layerProgress * totalHeight * 0.8; // 层中心Y
                    const layerH = totalHeight * 0.35; // 层高
                    const layerR = maxRadius * (1 - layerProgress * 0.8); // 层半径
                    
                    for(let k=0; k<particlesPerLayer && idx < CONFIG.particleCount; k++) {
                        // 圆锥体采样
                        const hPercent = Math.random(); // 0->1
                        const y = layerY + (hPercent - 0.5) * layerH;
                        
                        // 半径随高度收缩
                        const rMax = layerR * (1 - hPercent);
                        const r = Math.sqrt(Math.random()) * rMax; // 均匀分布
                        const angle = Math.random() * Math.PI * 2;
                        
                        let px = r * Math.cos(angle);
                        let py = y;
                        let pz = r * Math.sin(angle);

                        // 装饰物逻辑
                        // 1. 彩带 (Ribbon): 螺旋线
                        const ribbonAngle = (l * 2 + hPercent) * Math.PI * 2 + l;
                        // 2. 彩球 (Ornaments): 挂在树枝末端
                        const isTip = r > rMax * 0.85; 

                        if (Math.abs(angle - (ribbonAngle % (Math.PI*2))) < 0.2) {
                            // === 金色丝带 ===
                            // 强制移动到表面
                            px = rMax * 1.1 * Math.cos(ribbonAngle);
                            pz = rMax * 1.1 * Math.sin(ribbonAngle);
                            c[idx*3] = colors.gold[0]; c[idx*3+1] = colors.gold[1]; c[idx*3+2] = colors.gold[2];
                        } else if (isTip && Math.random() > 0.85) {
                            // === 彩球/彩灯 ===
                            // 稍微往外挂一点
                            px *= 1.1; pz *= 1.1;
                            
                            const type = Math.random();
                            if (type < 0.33) { // 红球
                                c[idx*3] = colors.red[0]; c[idx*3+1] = colors.red[1]; c[idx*3+2] = colors.red[2];
                            } else if (type < 0.66) { // 蓝球
                                c[idx*3] = colors.blue[0]; c[idx*3+1] = colors.blue[1]; c[idx*3+2] = colors.blue[2];
                            } else { // 暖白灯
                                c[idx*3] = colors.warmWhite[0]; c[idx*3+1] = colors.warmWhite[1]; c[idx*3+2] = colors.warmWhite[2];
                            }
                        } else {
                            // === 树叶 ===
                            // 深浅交替，增加体积感
                            const isLight = Math.random() > 0.6;
                            const col = isLight ? colors.leafLight : colors.leafDark;
                            c[idx*3] = col[0]; c[idx*3+1] = col[1]; c[idx*3+2] = col[2];
                        }

                        p[idx*3] = px; p[idx*3+1] = py; p[idx*3+2] = pz;
                        idx++;
                    }
                }
                
                return { pos: p, col: c };
            }
        };

        // 预生成
        const ShapeData = {
            open: Shapes.open(),
            fist: Shapes.tree(),
            pinch: Shapes.open() // 捏合时粒子也散开，给照片腾出空间
        };

        // ==========================================
        // 动画循环
        // ==========================================
        function animate() {
            if (stats) stats.begin();
            requestAnimationFrame(animate);

            // 更新 Debug FPS (简化，直接用 Stats)
            if (DEBUG_MODE && Math.random() > 0.9) {
                 // 偶尔更新一下 DOM 防止过频
                 // document.getElementById('debug-fps').innerText = ... 
            }

            // 1. 粒子动画 (Lerp 到目标位置)
            const pos = particles.geometry.attributes.position.array;
            const col = particles.geometry.attributes.color.array;
            const size = particles.geometry.attributes.size.array; // 获取大小数组
            const phase = particles.geometry.attributes.phase.array; // 获取相位数组
            
            // 速度系数 (优化：大幅提升粒子飞行速度，让变化看起来更干脆 0.06 -> 0.12)
            const lerpSpeed = 0.12; 
            const time = Date.now() * 0.001; // 当前时间

            for(let i=0; i<CONFIG.particleCount; i++) {
                // ... (位置插值保持不变)
                const noiseX = Math.sin(time + i) * 0.5; 
                const noiseY = Math.cos(time + i * 0.5) * 0.5;
                
                const tx = targetPosArray[i*3] * STATE.currentScale + STATE.handPos.x + noiseX;
                const ty = targetPosArray[i*3+1] * STATE.currentScale + STATE.handPos.y + noiseY;
                const tz = targetPosArray[i*3+2] * STATE.currentScale + STATE.handPos.z;

                pos[i*3] += (tx - pos[i*3]) * lerpSpeed;
                pos[i*3+1] += (ty - pos[i*3+1]) * lerpSpeed;
                pos[i*3+2] += (tz - pos[i*3+2]) * lerpSpeed;

                // 颜色插值
                col[i*3] += (targetColArray[i*3] - col[i*3]) * 0.05;
                col[i*3+1] += (targetColArray[i*3+1] - col[i*3+1]) * 0.05;
                col[i*3+2] += (targetColArray[i*3+2] - col[i*3+2]) * 0.05;
            }
            
            // 旋转底座效果：只有在树形态下才旋转
            if (STATE.gesture === 'fist') {
                particles.rotation.y += 0.005; // 缓慢自转
            } else {
                // 平滑回正
                particles.rotation.y += (0 - particles.rotation.y) * 0.1;
            }
            particles.rotation.z = Math.sin(time * 0.5) * 0.02; // 微弱摆动

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;

            // 2. 缩放平滑 (现在控制整个场景或相机距离)
            STATE.currentScale += (STATE.targetScale - STATE.currentScale) * 0.1;
            
            // 2.1 手势位置平滑 (解决低帧率识别导致的卡顿)
            STATE.handPos.lerp(STATE.targetHandPos, 0.1);

            // 2.2 照片动画更新 (必须每帧调用以保证平滑)
            updatePhotoVisibility();
            
            // === 实时更新照片位置以跟随粒子 ===
            // 必须在粒子位置更新后执行
            photoMeshes.forEach(mesh => {
                const hostIdx = mesh.userData.hostIdx;
                if (hostIdx !== undefined) {
                    // 从 position buffer 中获取当前粒子的实时坐标
                    const px = pos[hostIdx*3];
                    const py = pos[hostIdx*3+1];
                    const pz = pos[hostIdx*3+2];
                    
                    // 更新 Home Pos 为粒子当前位置
                    mesh.userData.homePos.set(px, py, pz);
                }
            });
            
            // 3. 相机动画系统 (Camera Animation System)
            const cam = STATE.camera;
            
            // 插值移动
            cam.currentPos.lerp(cam.targetPos, 0.05);
            cam.currentLookAt.lerp(cam.targetLookAt, 0.05);
            
            camera.position.copy(cam.currentPos);
            camera.lookAt(cam.currentLookAt);

            // 4. 雪花下落
            const snowP = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<snowCount; i++) {
                snowP[i*3+1] -= 0.5; // 下落
                if(snowP[i*3+1] < -150) snowP[i*3+1] = 150; // 循环
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            
            renderer.render(scene, camera);
            if (stats) stats.end();
        }
        animate();

        // ==========================================
        // 手势逻辑
        // ==========================================
        const videoElement = document.getElementById('video-input');
        
        const hands = new Hands({locateFile: (file) => {
            return `https://unpkg.com/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // 优化：降级为 Lite 模型 (0)，极大提升识别速度，减少延迟
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(results => {
            document.getElementById('loading').style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // ==========================================
                // 1. 高级手势识别 (Robust Gesture Detection)
                // ==========================================
                
                // 辅助：计算两点 2D 距离 (忽略 Z)
                const getDist = (i, j) => {
                    return Math.sqrt(Math.pow(lm[i].x - lm[j].x, 2) + Math.pow(lm[i].y - lm[j].y, 2));
                };

                // 基准尺度：掌心长度 (Wrist 0 -> Middle MCP 9)
                const palmLen = getDist(0, 9);
                
                // 手指定义
                // [Tip, PIP, MCP]
                const fingers = [
                    [8, 6, 5],   // Index
                    [12, 10, 9], // Middle
                    [16, 14, 13],// Ring
                    [20, 18, 17] // Pinky
                ];

                let extendedFingers = 0;
                
                // 检查四指是否伸直
                fingers.forEach(f => {
                    const tipToWrist = getDist(f[0], 0);
                    const pipToWrist = getDist(f[1], 0);
                    const mcpToWrist = getDist(f[2], 0);
                    
                    // 判定标准：
                    // 1. 指尖到手腕距离 > PIP到手腕距离 (基本几何)
                    // 2. 指尖到手腕距离 > 掌心长度 * 阈值 (防止蜷缩时的误判)
                    if (tipToWrist > pipToWrist * 1.1 && tipToWrist > palmLen * 0.8) {
                        extendedFingers++;
                    }
                });

                // 检查拇指 (单独逻辑)
                // 拇指 Tip(4) 到 Pinky MCP(17) 的距离如果很远，说明伸直
                const thumbTipToPinky = getDist(4, 17);
                const thumbExtended = thumbTipToPinky > palmLen * 0.9;
                if (thumbExtended) extendedFingers++;

                // 捏合检测 (Pinch)
                // 拇指尖(4) 与 食指尖(8) 距离
                const pinchDist = getDist(4, 8);
                const isPinch = pinchDist < palmLen * 0.25;

                // 原始手势判定
                let rawGesture = 'open';
                
                if (isPinch) {
                    rawGesture = 'pinch';
                } else {
                    // 握拳：伸直手指 <= 1 (允许大拇指或者某根手指稍微没收紧)
                    if (extendedFingers <= 1) {
                        rawGesture = 'fist';
                    } 
                    // 张手：伸直手指 >= 3
                    else if (extendedFingers >= 3) {
                        rawGesture = 'open';
                    }
                    // 模糊状态 (2根手指)：保持上一状态，或者倾向于 Open
                    else {
                         // Hysteresis (滞后)：如果上一次是 Fist，现在2根指头，可能还没张开完，保持 Fist
                         // 如果上一次是 Open，现在弯了2根，保持 Open
                         rawGesture = STATE.gestureHistory.last; 
                    }
                }

                // ==========================================
                // 2. 状态机与防抖 (State Machine & Debounce)
                // ==========================================
                const now = Date.now();
                const timeSinceLastSwitch = now - STATE.lastSwitchTime;

                // 更新 Debug 面板
                if (DEBUG_MODE) {
                    document.getElementById('debug-raw').innerText = rawGesture;
                    document.getElementById('debug-fingers').innerText = extendedFingers;
                    document.getElementById('debug-state').innerText = STATE.gesture;
                    document.getElementById('debug-lock').innerText = Math.max(0, STATE.lockDuration - timeSinceLastSwitch);
                }

                // 防抖计数器
                if (rawGesture === STATE.gestureHistory.last) {
                    STATE.gestureHistory.count++;
                } else {
                    STATE.gestureHistory.last = rawGesture;
                    STATE.gestureHistory.count = 1;
                }

                // 只有当新状态连续维持 N 帧，才尝试切换
                if (STATE.gestureHistory.count >= STATE.gestureHistory.confirmThreshold) {
                    const pendingGesture = STATE.gestureHistory.last;

                    // 检查是否在锁定时间内
                    if (timeSinceLastSwitch > STATE.lockDuration) {
                        if (STATE.gesture !== pendingGesture) {
                             // 执行切换
                             STATE.gesture = pendingGesture;
                             STATE.lastSwitchTime = now;
                             updateShape(pendingGesture);
                             
                             // 视觉/逻辑反馈
                             console.log(`[Switch] ${STATE.gesture}`);
                        }
                    }
                }

                // ==========================================
                // 3. 交互逻辑 (位置与缩放)
                // ==========================================
                
                // 平滑位置 (Lerp)
                const cx = lm[9].x; 
                const cy = lm[9].y;
                // 映射并反转X
                const targetX = -(cx - 0.5) * 200; 
                const targetY = -(cy - 0.5) * 150;
                
                // 更新目标位置 (在 animate 中平滑插值)
                STATE.targetHandPos.set(targetX, targetY, 0);
                // Z轴保持0

                // 缩放控制
                // 手离摄像头近(size大) -> 树变大
                const handSize = getDist(0, 9); // 掌心大小作为参考
                // handSize 通常在 0.1 (远) 到 0.3 (近) 之间
                let targetScale = 0.8 + handSize * 3.0; 
                
                // 限制缩放范围
                targetScale = Math.max(0.8, Math.min(2.0, targetScale));
                STATE.targetScale = targetScale;

            } else {
                // 无手检测
                // 缓慢归位
                STATE.targetHandPos.set(0, 0, 0);
                
                // 自动切回 Open (也需要防抖，避免闪烁)
                // 这里简单处理：如果长时间没手，才切回
                if (STATE.gesture !== 'open') {
                    // 可以加个无手计时器，这里简化
                     STATE.gesture = 'open';
                     updateShape('open');
                }
            }
        });
        
        // 独立出来的照片控制逻辑 (重写：控制照片飞入飞出)
         function updatePhotoVisibility() {
             // 目标照片索引
             const targetIdx = STATE.focusPhotoIdx % photoMeshes.length;
             
             // 仅在非圣诞树 (非 fist) 状态下显示照片
             // fist: 圣诞树 -> 隐藏
             // open: 散开 -> 显示小照片 (跟随粒子)
             // pinch: 捏合 -> 显示大照片 (飞向屏幕)
             const shouldShow = STATE.gesture !== 'fist';
 
             photoMeshes.forEach((mesh, i) => {
                 const isTarget = (i === targetIdx);
                 
                 if (!shouldShow) {
                     // 圣诞树模式：隐藏所有照片
                     mesh.visible = false;
                     mesh.material.opacity = 0;
                     return;
                 }
                 
                 // 如果是 Open 或 Pinch，照片可见
                 mesh.visible = true;
                 
                 if (STATE.gesture === 'pinch') {
                     // === 捏合状态 (Pinch Mode) ===
                     if (isTarget) {
                        // 目标位置：屏幕正中央 (用户要求不要跟随手势)
                        // Z=50 处于相机(100)和原点(0)之间，适中
                        const targetPos = new THREE.Vector3(0, 0, 50);
                        
                        // 目标旋转：归零 (正对屏幕)
                        const targetRot = new THREE.Euler(0, 0, 0);
                        
                        // 目标缩放：稍微缩小一点 (原 1.0 -> 0.6)
                        const targetScale = STATE.targetScale * 0.6;

                        // Lerp 动画 (加快飞入速度 0.1 -> 0.15)
                        mesh.position.lerp(targetPos, 0.15);
                        mesh.rotation.x += (targetRot.x - mesh.rotation.x) * 0.15;
                        mesh.rotation.y += (targetRot.y - mesh.rotation.y) * 0.15;
                        mesh.rotation.z += (targetRot.z - mesh.rotation.z) * 0.15;
                        
                        mesh.scale.setScalar(mesh.scale.x + (targetScale - mesh.scale.x) * 0.15);
                        mesh.material.opacity += (1.0 - mesh.material.opacity) * 0.15;
                         
                     } else {
                         // 2. 非目标照片：紧紧跟随宿主粒子
                         // 平滑移动到粒子位置 (homePos 已经在 animate 中更新为粒子位置)
                         mesh.position.lerp(mesh.userData.homePos, 0.2); // 增加 lerp 速度 (0.05 -> 0.2) 以减少滞后
                         mesh.scale.setScalar(mesh.scale.x + (0.15 - mesh.scale.x) * 0.1); // 保持微缩
                         mesh.material.opacity += (0.8 - mesh.material.opacity) * 0.1; 
                     }
                 } else {
                     // === 松开状态 (Open Mode) ===
                     // 所有照片紧紧跟随宿主粒子
                     mesh.position.lerp(mesh.userData.homePos, 0.2); // 紧跟粒子
                     
                     // 恢复混乱旋转
                     mesh.rotation.x += (mesh.userData.homeRot.x - mesh.rotation.x) * 0.08;
                     mesh.rotation.y += (mesh.userData.homeRot.y - mesh.rotation.y) * 0.08;
                     mesh.rotation.z += (mesh.userData.homeRot.z - mesh.rotation.z) * 0.08;
                     
                     // 恢复微缩
                     mesh.scale.setScalar(mesh.scale.x + (0.15 - mesh.scale.x) * 0.1); 
                     mesh.material.opacity += (0.8 - mesh.material.opacity) * 0.1;
                 }
             });
            
            // 2. 相机逻辑
            // 移除聚焦逻辑，保持全景模式，这样手移动时画面才会跟着动
            // if (STATE.gesture === 'pinch') { ... } 
            
            // 始终保持全景模式
            // 如果是从 pinch 变回来的，需要切换到下一张
            if (STATE.gesture === 'pinch') {
                STATE.camera.isZooming = true;
            } else {
                if (STATE.camera.isZooming) {
                    // 刚松手
                    STATE.focusPhotoIdx = (STATE.focusPhotoIdx + 1) % photoMeshes.length;
                    STATE.camera.isZooming = false;
                }
            }
            
            // 复位相机到标准位置，这样画面才会随着 handPos 移动 (因为 handPos 控制的是粒子的偏移)
            STATE.camera.targetPos.set(0, 0, CONFIG.camZ);
            STATE.camera.targetLookAt.set(0, 0, 0);
        }

        function updateShape(gesture) {
            const data = ShapeData[gesture];
            if (!data) return;
            
            // 复制目标数据
            for(let i=0; i<CONFIG.particleCount * 3; i++) {
                targetPosArray[i] = data.pos[i];
                targetColArray[i] = data.col[i];
            }

            // UI 联动
            const title = document.getElementById('title-text');
            if (gesture === 'fist') {
                title.style.opacity = 1;
            } else {
                title.style.opacity = 0;
            }
        }

        // const cameraUtils = new Camera(...); 移除这里的初始化
        /* 
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { 
                // 极致响应：移除帧率限制，全力运行
                // 配合 modelComplexity: 0 (Lite)，大多数设备都能跑满，且延迟最低
                await hands.send({image: videoElement}); 
            },
            width: 640, height: 480
        });
        */
        // 移除自动启动，改为完全手动控制
        // cameraUtils.start().catch(...) 
        
        // 初始状态提示
        document.getElementById('loading').innerHTML = "准备就绪<br><span style='font-size:16px'>请点击右上角按钮启动摄像头</span>";

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==========================================
        // 音乐自动播放逻辑
        // ==========================================
        const bgm = document.getElementById('bgm');
        
        // 尝试自动播放
        function tryPlayMusic() {
            bgm.volume = 0.5; // 默认音量 50%
            bgm.play().then(() => {
                console.log("BGM autoplay success");
            }).catch(error => {
                console.log("BGM autoplay blocked, waiting for user interaction");
                // 如果自动播放失败（被浏览器拦截），则监听首次点击事件来播放
                document.body.addEventListener('click', () => {
                    bgm.play();
                }, { once: true }); // 只执行一次
            });
        }
        
        // 页面加载完成后尝试播放
        tryPlayMusic();

        // ==========================================
        // 摄像头手动控制 (Native getUserMedia 版)
        // ==========================================
        const camBtn = document.getElementById('cam-toggle');
        let isCameraRunning = false;
        let animationFrameId = null;

        // 手动处理视频帧循环
        async function onCameraFrame() {
            if (!isCameraRunning) return;
            
            // 发送给 MediaPipe
            await hands.send({image: videoElement});
            
            // 循环调用
            animationFrameId = requestAnimationFrame(onCameraFrame);
        }

        // 启动摄像头函数
        async function startCamera() {
            document.getElementById('loading').innerHTML = "正在启动摄像头...";
            document.getElementById('loading').style.display = 'block';

            try {
                // 1. 确保旧流已停止
                if (videoElement.srcObject) {
                    const tracks = videoElement.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    videoElement.srcObject = null;
                }

                // 2. 原生请求摄像头 (最宽松模式，避免分辨率不匹配导致的错误)
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: true // 不指定具体分辨率，让浏览器自动选择可用的
                });

                // 3. 绑定到 video 标签
                videoElement.srcObject = stream;
                videoElement.play(); // 直接播放

                // 5. 启动帧循环
                isCameraRunning = true;
                onCameraFrame();

                camBtn.innerHTML = "⏹ 释放摄像头";
                camBtn.style.background = "rgba(255,255,255,0.2)";
                document.getElementById('loading').style.display = 'none';

            } catch (e) {
                console.error(e);
                let msg = "启动失败: " + e.message;
                if (e.name === 'NotReadableError' || e.name === 'TrackStartError') {
                    msg = "摄像头仍被占用";
                } else if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
                    msg = "权限被拒绝";
                }
                document.getElementById('loading').innerHTML = msg + "<br><span style='font-size:14px'>请尝试：<br>1. 关闭所有浏览器窗口<br>2. 重新拔插摄像头<br>3. 刷新页面</span>";
            }
        }

        // 停止摄像头函数
        function stopCamera() {
            isCameraRunning = false;
            
            // 停止循环
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // 停止视频播放
            videoElement.pause();

            // 停止硬件流
            if (videoElement.srcObject) {
                const tracks = videoElement.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                videoElement.srcObject = null;
            }
            
            camBtn.innerHTML = "▶ 启动摄像头";
            camBtn.style.background = "rgba(0,255,0,0.3)";
            document.getElementById('loading').innerHTML = "摄像头已释放<br>现在可以在其他页面使用了";
            document.getElementById('loading').style.display = 'block';
        }
        
        camBtn.onclick = () => {
            if (isCameraRunning) {
                stopCamera();
            } else {
                startCamera();
            }
        };

    </script>
</body>
</html>