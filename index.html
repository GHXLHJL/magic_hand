<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR 粒子互动系统 - Mok</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        #video-input {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            z-index: 2;
            opacity: 0.5;
            border-radius: 8px;
            border: 1px solid #00ffff;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 24px;
            z-index: 10;
            pointer-events: none;
            text-align: center;
        }
        #debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(0, 255, 255, 0.7);
            font-size: 14px;
            z-index: 2;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    
    <!-- 加载 Three.js -->
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <!-- 加载 MediaPipe Hands -->
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loading">正在初始化视觉核心...<br><span style="font-size:14px; opacity:0.7">请允许摄像头权限</span></div>
    <div id="debug-info">
        状态: 等待手势...<br>
        手势: 无<br>
        粒子数: 16000
    </div>
    <video id="video-input"></video>
    <div id="canvas-container"></div>

    <script>
        // ==========================================
        // 全局配置
        // ==========================================
        const CONFIG = {
            particleCount: 16000,
            color: 0x00ffff,
            camFov: 75,
            camZ: 100,
            textString: "我是 Mok",
            physics: {
                friction: 0.94,      // 摩擦力 (越小阻力越大，停得越快)
                ease: 0.008,         // 牵引力平滑度 (极低值 = 极慢的漂浮感)
                explosionForce: 1.5, // 切换爆炸力度 (减弱爆炸，避免太乱)
                stormThreshold: 30,  // 挥手风暴触发速度阈值
                stormForce: 1.0      // 风暴吹散力度 (减弱风力)
            }
        };

        // ==========================================
        // 状态管理
        // ==========================================
        const STATE = {
            currentGesture: 'none',
            handPosition: new THREE.Vector3(),
            handVelocity: new THREE.Vector3(),
            lastHandPosition: new THREE.Vector3(),
            handScale: 1.0,
            targetPositions: null, // Float32Array
            needsExplosion: false
        };

        // ==========================================
        // Three.js 初始化
        // ==========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // 添加一点迷雾增强深度感
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(CONFIG.camFov, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.camZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // ==========================================
        // 粒子系统核心
        // ==========================================
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const velocities = new Float32Array(CONFIG.particleCount * 3);
        // 目标位置缓存，用于不同形态
        let currentTargetPositions = new Float32Array(CONFIG.particleCount * 3);

        // 初始化随机位置
        for (let i = 0; i < CONFIG.particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 200;
            velocities[i] = 0;
            currentTargetPositions[i] = positions[i];
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // 材质
        const particleMaterial = new THREE.PointsMaterial({
            color: CONFIG.color,
            size: 0.8,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
        scene.add(particleSystem);

        // ==========================================
        // 形状生成器 (数学模型)
        // ==========================================
        const Shapes = {
            // 1. 张手 -> 球体
            sphere: () => {
                const arr = new Float32Array(CONFIG.particleCount * 3);
                const radius = 35;
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const phi = Math.acos(-1 + (2 * i) / CONFIG.particleCount);
                    const theta = Math.sqrt(CONFIG.particleCount * Math.PI) * phi;
                    arr[i * 3] = radius * Math.cos(theta) * Math.sin(phi);
                    arr[i * 3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
                    arr[i * 3 + 2] = radius * Math.cos(phi);
                }
                return arr;
            },

            // 2. 握拳 -> 圆环
            torus: () => {
                const arr = new Float32Array(CONFIG.particleCount * 3);
                const R = 30; // 大半径
                const r = 10; // 小半径
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI * 2;
                    arr[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);
                    arr[i * 3 + 1] = (R + r * Math.cos(v)) * Math.sin(u);
                    arr[i * 3 + 2] = r * Math.sin(v);
                }
                return arr;
            },

            // 3. 竖大拇指 -> 爱心
            heart: () => {
                const arr = new Float32Array(CONFIG.particleCount * 3);
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    // 心形 parametric equation
                    const t = Math.random() * Math.PI * 2;
                    // 为了填充内部，引入随机因子
                    const scale = Math.sqrt(Math.random()) * 2.5; 
                    
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    
                    arr[i * 3] = x * scale;
                    arr[i * 3 + 1] = y * scale;
                    arr[i * 3 + 2] = (Math.random() - 0.5) * 10; // 给一点厚度
                }
                return arr;
            },

            // 4. 食指 -> 星形
            star: () => {
                const arr = new Float32Array(CONFIG.particleCount * 3);
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const rBase = 40;
                    // 简单的五角星极坐标模拟
                    const a = 5; // 5个角
                    const r = rBase * (0.5 + 0.5 * Math.cos(a * angle));
                    
                    // 填充
                    const finalR = r * Math.sqrt(Math.random());

                    arr[i * 3] = finalR * Math.cos(angle);
                    arr[i * 3 + 1] = finalR * Math.sin(angle);
                    arr[i * 3 + 2] = (Math.random() - 0.5) * 5;
                }
                return arr;
            },

            // 5. 剪刀手 -> 文字 "我是 Mok"
            text: () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 500;
                canvas.height = 200;
                // document.body.appendChild(canvas); // Debug use

                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 100px "Microsoft YaHei", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(CONFIG.textString, canvas.width / 2, canvas.height / 2);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const validPixels = [];

                for (let y = 0; y < canvas.height; y += 2) { // 采样步长
                    for (let x = 0; x < canvas.width; x += 2) {
                        const index = (y * canvas.width + x) * 4;
                        if (data[index] > 128) { // 红色通道 > 128 (因为是白色文字)
                            validPixels.push({
                                x: (x - canvas.width / 2) * 0.3, // 缩放因子
                                y: -(y - canvas.height / 2) * 0.3, // 翻转Y轴
                                z: 0
                            });
                        }
                    }
                }

                const arr = new Float32Array(CONFIG.particleCount * 3);
                if (validPixels.length === 0) return Shapes.sphere(); // Fallback

                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const p = validPixels[i % validPixels.length];
                    arr[i * 3] = p.x;
                    arr[i * 3 + 1] = p.y;
                    arr[i * 3 + 2] = (Math.random() - 0.5) * 5; // 厚度
                }
                return arr;
            }
        };

        // 预计算所有形状
        console.log("正在生成形状缓存...");
        const ShapeCache = {
            sphere: Shapes.sphere(),
            torus: Shapes.torus(),
            heart: Shapes.heart(),
            star: Shapes.star(),
            text: Shapes.text()
        };
        console.log("形状缓存完成");

        // ==========================================
        // MediaPipe 手势识别逻辑
        // ==========================================
        const videoElement = document.getElementById('video-input');
        const debugInfo = document.getElementById('debug-info');

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. 计算手掌中心 (作为粒子系统的吸引中心)
                // 使用手腕(0)和中指根部(9)的中间点
                const wrist = landmarks[0];
                const middleMCP = landmarks[9];
                
                // 转换 MediaPipe 坐标 (0-1) 到 Three.js 世界坐标 (approx -50 to 50)
                const targetX = (0.5 - wrist.x) * 150; // 反转X轴因为镜像
                const targetY = (0.5 - wrist.y) * 100;
                // 深度估算: 手越大越近。利用 0 和 9 的距离
                const handSize = Math.sqrt(Math.pow(wrist.x - middleMCP.x, 2) + Math.pow(wrist.y - middleMCP.y, 2));
                const targetZ = (handSize - 0.1) * 200; 

                // 更新状态位置
                STATE.lastHandPosition.copy(STATE.handPosition);
                STATE.handPosition.set(targetX, targetY, targetZ);
                
                // 计算手速 (用于风暴交互)
                STATE.handVelocity.subVectors(STATE.handPosition, STATE.lastHandPosition);
                
                // 2. 深度缩放系数
                STATE.handScale = 0.5 + handSize * 3; // 动态调整粒子系统大小

                // 3. 手势识别
                const gesture = detectGesture(landmarks);
                
                if (gesture !== STATE.currentGesture) {
                    STATE.currentGesture = gesture;
                    STATE.needsExplosion = true;
                    updateTargetShape(gesture);
                    
                    // UI 更新
                    let gestureName = "未知";
                    if (gesture === 'open') gestureName = "张手 (球体)";
                    if (gesture === 'fist') gestureName = "握拳 (圆环)";
                    if (gesture === 'victory') gestureName = "剪刀手 (Mok)";
                    if (gesture === 'point') gestureName = "食指 (星形)";
                    if (gesture === 'thumb') gestureName = "点赞 (爱心)";
                    
                    debugInfo.innerHTML = `
                        状态: 交互中<br>
                        手势: ${gestureName}<br>
                        粒子数: ${CONFIG.particleCount}<br>
                        手速: ${STATE.handVelocity.length().toFixed(2)}
                    `;
                }

            } else {
                // 没有检测到手，慢慢回到中心
                STATE.handPosition.lerp(new THREE.Vector3(0, 0, 0), 0.05);
                STATE.handVelocity.set(0, 0, 0);
            }
        }

        function isFingerExtended(landmarks, fingerTipIdx, fingerPipIdx) {
            return landmarks[fingerTipIdx].y < landmarks[fingerPipIdx].y;
        }

        function detectGesture(lm) {
            // 简单的手指状态判断 (Y轴向上为负)
            // 拇指判断比较特殊，看X轴或者相对于手掌的角度，这里简化判断
            const thumbOpen = Math.abs(lm[4].x - lm[0].x) > 0.05; 
            const indexOpen = lm[8].y < lm[6].y;
            const middleOpen = lm[12].y < lm[10].y;
            const ringOpen = lm[16].y < lm[14].y;
            const pinkyOpen = lm[20].y < lm[18].y;

            const count = [indexOpen, middleOpen, ringOpen, pinkyOpen].filter(Boolean).length;

            if (indexOpen && middleOpen && !ringOpen && !pinkyOpen) return 'victory'; // 剪刀手
            if (count === 4 && thumbOpen) return 'open'; // 张手
            if (count === 0 && !thumbOpen) return 'fist'; // 握拳
            if (indexOpen && !middleOpen && !ringOpen && !pinkyOpen) return 'point'; // 食指
            if (thumbOpen && !indexOpen && !middleOpen && !ringOpen && !pinkyOpen) return 'thumb'; // 大拇指

            return STATE.currentGesture; // 保持上一状态
        }

        function updateTargetShape(gesture) {
            switch(gesture) {
                case 'open': currentTargetPositions = ShapeCache.sphere; break;
                case 'fist': currentTargetPositions = ShapeCache.torus; break;
                case 'victory': currentTargetPositions = ShapeCache.text; break;
                case 'point': currentTargetPositions = ShapeCache.star; break;
                case 'thumb': currentTargetPositions = ShapeCache.heart; break;
                default: currentTargetPositions = ShapeCache.sphere;
            }
        }

        // ==========================================
        // 物理循环
        // ==========================================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            
            // 粒子物理更新
            const p = particlesGeometry.attributes.position.array;
            
            // 获取手部影响
            const handSpeed = STATE.handVelocity.length();
            const isStorm = handSpeed > CONFIG.physics.stormThreshold;
            const stormCenter = STATE.handPosition;

            // 爆炸标志
            let explosionForce = 0;
            if (STATE.needsExplosion) {
                explosionForce = CONFIG.physics.explosionForce;
                STATE.needsExplosion = false;
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const idx = i * 3;
                
                // 1. 获取目标位置 (加上手部偏移)
                // 目标位置是：当前形状的本地坐标 * 缩放 + 手部世界坐标
                const tx = currentTargetPositions[idx] * STATE.handScale + STATE.handPosition.x;
                const ty = currentTargetPositions[idx+1] * STATE.handScale + STATE.handPosition.y;
                const tz = currentTargetPositions[idx+2] * STATE.handScale + STATE.handPosition.z;

                // 2. 物理加速度: 弹簧力 (Hooke's Law)
                // ax = (target - current) * springStrength
                const ax = (tx - p[idx]) * CONFIG.physics.ease;
                const ay = (ty - p[idx+1]) * CONFIG.physics.ease;
                const az = (tz - p[idx+2]) * CONFIG.physics.ease;

                // 3. 更新速度
                velocities[idx] += ax;
                velocities[idx+1] += ay;
                velocities[idx+2] += az;

                // 4. 应用爆炸特效 (瞬间斥力)
                if (explosionForce > 0) {
                    // 随机方向
                    velocities[idx] += (Math.random() - 0.5) * explosionForce * 10;
                    velocities[idx+1] += (Math.random() - 0.5) * explosionForce * 10;
                    velocities[idx+2] += (Math.random() - 0.5) * explosionForce * 10;
                }

                // 5. 应用挥手风暴 (Wave Storm)
                if (isStorm) {
                    // 计算粒子到手的距离
                    const dx = p[idx] - stormCenter.x;
                    const dy = p[idx+1] - stormCenter.y;
                    const dz = p[idx+2] - stormCenter.z;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    
                    if (distSq < 2500) { // 50 units range
                        const force = CONFIG.physics.stormForce * handSpeed / (Math.sqrt(distSq) + 1);
                        // 沿着手速方向施加力
                        velocities[idx] += STATE.handVelocity.x * force * 0.1;
                        velocities[idx+1] += STATE.handVelocity.y * force * 0.1;
                        velocities[idx+2] += STATE.handVelocity.z * force * 0.1;
                    }
                }

                // 6. 摩擦力 (Damping)
                velocities[idx] *= CONFIG.physics.friction;
                velocities[idx+1] *= CONFIG.physics.friction;
                velocities[idx+2] *= CONFIG.physics.friction;

                // 7. 更新位置
                p[idx] += velocities[idx];
                p[idx+1] += velocities[idx+1];
                p[idx+2] += velocities[idx+2];
            }

            particlesGeometry.attributes.position.needsUpdate = true;
            
            // 粒子系统整体稍微旋转一点，增加动感
            particleSystem.rotation.y += 0.001;

            renderer.render(scene, camera);
        }

        // ==========================================
        // 初始化 MediaPipe Camera
        // ==========================================
        const hands = new Hands({locateFile: (file) => {
            return `https://unpkg.com/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // 启动
        cameraUtils.start()
            .then(() => {
                console.log("Camera started");
                animate();
            })
            .catch(err => {
                console.error("Camera failed", err);
                document.getElementById('loading').innerHTML = "摄像头启动失败<br>请检查权限或使用 HTTPS";
            });

        // 窗口调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
