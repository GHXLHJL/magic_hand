<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR 粒子互动系统 - Mok</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        #video-input {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 160px;
            height: 120px;
            transform: scaleX(-1);
            z-index: 2;
            opacity: 0.5;
            border-radius: 8px;
            border: 1px solid #00ffff;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 24px;
            z-index: 10;
            pointer-events: none;
            text-align: center;
        }
        #debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(0, 255, 255, 0.7);
            font-size: 14px;
            z-index: 2;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
    
    <!-- 加载 Three.js -->
    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <!-- 加载 MediaPipe Hands -->
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loading">正在初始化视觉核心...<br><span style="font-size:14px; opacity:0.7">请允许摄像头权限</span></div>
    <div id="debug-info">
        状态: 等待手势...<br>
        手势: 无<br>
        粒子数: 16000
    </div>
    <video id="video-input"></video>
    <div id="canvas-container"></div>

    <script>
        // ==========================================
        // 全局配置
        // ==========================================
        const CONFIG = {
            particleCount: 16000,
            color: 0x00ffff,
            camFov: 75,
            camZ: 100,
            textString: "我是 Mok",
            physics: {
                friction: 0.94,      // 摩擦力 (越小阻力越大，停得越快)
                ease: 0.008,         // 牵引力平滑度 (极低值 = 极慢的漂浮感)
                explosionForce: 1.5, // 切换爆炸力度 (减弱爆炸，避免太乱)
                stormThreshold: 30,  // 挥手风暴触发速度阈值
                stormForce: 1.0      // 风暴吹散力度 (减弱风力)
            }
        };

        // ==========================================
        // 状态管理
        // ==========================================
        const STATE = {
            currentGesture: 'none',
            handPosition: new THREE.Vector3(),
            handVelocity: new THREE.Vector3(),
            lastHandPosition: new THREE.Vector3(),
            handScale: 1.0,
            targetPositions: null, // Float32Array
            needsExplosion: false
        };

        // ==========================================
        // Three.js 初始化
        // ==========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // 添加一点迷雾增强深度感
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(CONFIG.camFov, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.camZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // ==========================================
        // 粒子系统核心
        // ==========================================
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const velocities = new Float32Array(CONFIG.particleCount * 3);
        // 增加颜色属性，支持每个粒子独立颜色
        const colors = new Float32Array(CONFIG.particleCount * 3);
        // 目标位置缓存，用于不同形态
        let currentTargetPositions = new Float32Array(CONFIG.particleCount * 3);
        // 目标颜色缓存
        let currentTargetColors = new Float32Array(CONFIG.particleCount * 3);

        // 初始化随机位置和默认颜色 (青色)
        const defaultColor = new THREE.Color(CONFIG.color);
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const idx = i * 3;
            positions[idx] = (Math.random() - 0.5) * 200;
            positions[idx+1] = (Math.random() - 0.5) * 200;
            positions[idx+2] = (Math.random() - 0.5) * 200;
            velocities[idx] = 0;
            velocities[idx+1] = 0;
            velocities[idx+2] = 0;
            
            currentTargetPositions[idx] = positions[idx];
            
            // 初始化颜色
            colors[idx] = defaultColor.r;
            colors[idx+1] = defaultColor.g;
            colors[idx+2] = defaultColor.b;
            currentTargetColors[idx] = defaultColor.r;
            currentTargetColors[idx+1] = defaultColor.g;
            currentTargetColors[idx+2] = defaultColor.b;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // 材质 - 开启 vertexColors
        const particleMaterial = new THREE.PointsMaterial({
            vertexColors: true, // 启用顶点颜色
            size: 0.8,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
        scene.add(particleSystem);

        // ==========================================
        // 形状生成器 (数学模型)
        // ==========================================
        // 每个形状返回 { pos: Float32Array, col: Float32Array }
        const defaultColorArr = new Float32Array(CONFIG.particleCount * 3);
        const c = new THREE.Color(CONFIG.color);
        for(let i=0; i<CONFIG.particleCount; i++) {
            defaultColorArr[i*3] = c.r; defaultColorArr[i*3+1] = c.g; defaultColorArr[i*3+2] = c.b;
        }

        const Shapes = {
            // 1. 张手 -> 散开 (大球体)
            sphere: () => {
                const arr = new Float32Array(CONFIG.particleCount * 3);
                const radius = 120; // 增大半径，模拟散开
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const phi = Math.acos(-1 + (2 * i) / CONFIG.particleCount);
                    const theta = Math.sqrt(CONFIG.particleCount * Math.PI) * phi;
                    // 增加更强的随机性，看起来像云雾
                    const r = radius * (0.5 + Math.random());
                    arr[i * 3] = r * Math.cos(theta) * Math.sin(phi);
                    arr[i * 3 + 1] = r * Math.sin(theta) * Math.sin(phi);
                    arr[i * 3 + 2] = r * Math.cos(phi);
                }
                return arr;
            },

            // 2. 握拳 -> 圣诞树 (复刻照片效果)
            tree: () => {
                const pos = new Float32Array(CONFIG.particleCount * 3);
                const col = new Float32Array(CONFIG.particleCount * 3);
                
                const treeHeight = 120;
                const trunkHeight = 30;
                const maxRadius = 45;
                
                const green = new THREE.Color(0x2ecc71); // 鲜艳的绿
                const darkGreen = new THREE.Color(0x27ae60);
                const pink = new THREE.Color(0xff69b4); // 树干粉色
                const yellow = new THREE.Color(0xf1c40f); // 装饰灯
                const white = new THREE.Color(0xffffff); // 顶部雪/星

                for (let i = 0; i < CONFIG.particleCount; i++) {
                    // 分配粒子：15% 给树干，85% 给树冠
                    if (i < CONFIG.particleCount * 0.15) {
                        // === 树干 (粉色圆柱) ===
                        const h = Math.random() * trunkHeight;
                        const r = Math.random() * 8; // 树干半径
                        const angle = Math.random() * Math.PI * 2;
                        
                        pos[i * 3] = r * Math.cos(angle);
                        pos[i * 3 + 1] = h - treeHeight/2 - trunkHeight/2; // 底部位置
                        pos[i * 3 + 2] = r * Math.sin(angle);
                        
                        col[i*3] = pink.r; col[i*3+1] = pink.g; col[i*3+2] = pink.b;
                    } else {
                        // === 树冠 (绿色圆锥 + 装饰) ===
                        // 这是一个圆锥体，底部宽，顶部尖
                        // y 范围: -treeHeight/2 + trunkHeight/2  到  treeHeight/2
                        const yPercent = Math.random(); // 0 -> 1
                        // 形状函数：y越小(底部)，半径越大
                        const currentMaxR = maxRadius * (1 - yPercent); 
                        const r = Math.sqrt(Math.random()) * currentMaxR; // 均匀分布在圆内
                        const angle = Math.random() * Math.PI * 2;
                        
                        const y = -treeHeight/2 + trunkHeight/2 + yPercent * (treeHeight - trunkHeight);
                        
                        pos[i * 3] = r * Math.cos(angle);
                        pos[i * 3 + 1] = y;
                        pos[i * 3 + 2] = r * Math.sin(angle);

                        // 颜色分配
                        const rand = Math.random();
                        if (rand > 0.92) { // 8% 装饰灯 (黄/白)
                            const deco = Math.random() > 0.5 ? yellow : white;
                            col[i*3] = deco.r; col[i*3+1] = deco.g; col[i*3+2] = deco.b;
                            // 装饰灯稍微往外凸一点
                            pos[i * 3] *= 1.05;
                            pos[i * 3 + 2] *= 1.05;
                        } else {
                            // 树叶深浅绿交替
                            const leaf = Math.random() > 0.5 ? green : darkGreen;
                            col[i*3] = leaf.r; col[i*3+1] = leaf.g; col[i*3+2] = leaf.b;
                        }
                    }
                }
                
                // 简单的 "Merry Christmas" 文字粒子 (复用部分树冠粒子放在头顶)
                // 这里为了性能和简单，我们用一部分粒子在树顶排列成一行简单的点阵
                // 实际上完整的文字需要 canvas 采样，暂且用树冠本身的装饰代表
                
                return { pos, col };
            },

            // 3. 竖大拇指 -> 爱心
            heart: () => {
                const arr = new Float32Array(CONFIG.particleCount * 3);
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    // 心形 parametric equation
                    const t = Math.random() * Math.PI * 2;
                    // 为了填充内部，引入随机因子
                    const scale = Math.sqrt(Math.random()) * 2.5; 
                    
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    
                    arr[i * 3] = x * scale;
                    arr[i * 3 + 1] = y * scale;
                    arr[i * 3 + 2] = (Math.random() - 0.5) * 10; // 给一点厚度
                }
                return arr;
            },

            // 4. 食指 -> 星形
            star: () => {
                const arr = new Float32Array(CONFIG.particleCount * 3);
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const rBase = 40;
                    // 简单的五角星极坐标模拟
                    const a = 5; // 5个角
                    const r = rBase * (0.5 + 0.5 * Math.cos(a * angle));
                    
                    // 填充
                    const finalR = r * Math.sqrt(Math.random());

                    arr[i * 3] = finalR * Math.cos(angle);
                    arr[i * 3 + 1] = finalR * Math.sin(angle);
                    arr[i * 3 + 2] = (Math.random() - 0.5) * 5;
                }
                return arr;
            },

            // 5. 剪刀手 -> 文字 "我是 Mok"
            text: () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 500;
                canvas.height = 200;
                // document.body.appendChild(canvas); // Debug use

                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 100px "Microsoft YaHei", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(CONFIG.textString, canvas.width / 2, canvas.height / 2);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const validPixels = [];

                for (let y = 0; y < canvas.height; y += 2) { // 采样步长
                    for (let x = 0; x < canvas.width; x += 2) {
                        const index = (y * canvas.width + x) * 4;
                        if (data[index] > 128) { // 红色通道 > 128 (因为是白色文字)
                            validPixels.push({
                                x: (x - canvas.width / 2) * 0.3, // 缩放因子
                                y: -(y - canvas.height / 2) * 0.3, // 翻转Y轴
                                z: 0
                            });
                        }
                    }
                }

                const arr = new Float32Array(CONFIG.particleCount * 3);
                if (validPixels.length === 0) return Shapes.sphere(); // Fallback

                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const p = validPixels[i % validPixels.length];
                    arr[i * 3] = p.x;
                    arr[i * 3 + 1] = p.y;
                    arr[i * 3 + 2] = (Math.random() - 0.5) * 5; // 厚度
                }
                return arr;
            }
        };

        // 预计算所有形状
        console.log("正在生成形状缓存...");
        const ShapeCache = {
            sphere: Shapes.sphere(),
            tree: Shapes.tree(),
            heart: Shapes.heart(),
            star: Shapes.star(),
            text: Shapes.text()
        };
        console.log("形状缓存完成");

        // ==========================================
        // MediaPipe 手势识别逻辑
        // ==========================================
        const videoElement = document.getElementById('video-input');
        const debugInfo = document.getElementById('debug-info');

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. 计算手掌中心 (作为粒子系统的吸引中心)
                // 使用手掌几何中心：(Wrist + Middle_MCP) / 2
                // 这比单纯用手腕更准确，能让粒子球体位于手心
                const wrist = landmarks[0];
                const middleMCP = landmarks[9];
                
                const palmX = (wrist.x + middleMCP.x) / 2;
                const palmY = (wrist.y + middleMCP.y) / 2;
                
                // 转换 MediaPipe 坐标 (0-1) 到 Three.js 世界坐标
                // 重新校准映射比例，使其更符合 75度 FOV 的可视范围
                // 视口高度约为 150 (Z=0时), 宽度约为 150 * aspect
                const viewHeight = 150; 
                const viewWidth = viewHeight * (window.innerWidth / window.innerHeight);
                
                // X轴: 镜像反转 (MediaPipe x是归一化的，0在左，1在右)
                // 我们希望：手在画面左边(x<0.5) -> 粒子在左边(x<0); 手在右边(x>0.5) -> 粒子在右边(x>0)
                // 由于通常自拍镜像是反的，我们加负号来匹配
                const targetX = -(palmX - 0.5) * viewWidth; 
                
                // Y轴: MediaPipe y向下增大(0顶1底)，ThreeJS y向上增大
                // y<0.5(上) -> targetY>0; y>0.5(下) -> targetY<0
                const targetY = -(palmY - 0.5) * viewHeight;
                
                // 深度估算: 手越大越近。利用 0 和 9 的距离
                const handSize = Math.sqrt(Math.pow(wrist.x - middleMCP.x, 2) + Math.pow(wrist.y - middleMCP.y, 2));
                
                // 深度修正：放弃复杂的 Z 轴移动，改为主要靠缩放 (Scale) 来模拟距离感
                // 这样能避免 Z 轴跑出相机视野的问题
                // Z 轴只做微调，保持在 0 附近
                const targetZ = 0; 

                // 更新状态位置
                STATE.lastHandPosition.copy(STATE.handPosition);
                // 使用 lerp 平滑移动，避免抖动
                const targetPos = new THREE.Vector3(targetX, targetY, targetZ);
                STATE.handPosition.lerp(targetPos, 0.2); // 0.2 的平滑系数
                
                // 计算手速 (用于风暴交互)
                STATE.handVelocity.subVectors(STATE.handPosition, STATE.lastHandPosition);
                
                // 2. 深度缩放系数 (根据 handSize 动态调整大小)
                // handSize 通常在 0.05 (远) 到 0.3 (近) 之间
                // 我们希望 Scale 在 0.5 到 2.0 之间
                STATE.handScale = 0.5 + handSize * 5;

                // 3. 手势识别
                const gesture = detectGesture(landmarks);
                
                if (gesture !== STATE.currentGesture) {
                    STATE.currentGesture = gesture;
                    STATE.needsExplosion = true;
                    updateTargetShape(gesture);
                    
                    // UI 更新
                    let gestureName = "未知";
                    if (gesture === 'open') gestureName = "张手 (散开)";
                    if (gesture === 'fist') gestureName = "握拳 (圣诞树)";
                    if (gesture === 'victory') gestureName = "剪刀手 (Mok)";
                    if (gesture === 'point') gestureName = "食指 (星形)";
                    if (gesture === 'thumb') gestureName = "点赞 (爱心)";
                    
                    debugInfo.innerHTML = `
                        状态: 交互中<br>
                        手势: ${gestureName}<br>
                        粒子数: ${CONFIG.particleCount}<br>
                        手速: ${STATE.handVelocity.length().toFixed(2)}
                    `;
                }

            } else {
                // 没有检测到手，慢慢回到中心
                STATE.handPosition.lerp(new THREE.Vector3(0, 0, 0), 0.05);
                STATE.handVelocity.set(0, 0, 0);
            }
        }

        function isFingerExtended(landmarks, fingerTipIdx, fingerPipIdx) {
            return landmarks[fingerTipIdx].y < landmarks[fingerPipIdx].y;
        }

        function detectGesture(lm) {
            // 简单的手指状态判断 (Y轴向上为负)
            // 拇指判断比较特殊，看X轴或者相对于手掌的角度，这里简化判断
            const thumbOpen = Math.abs(lm[4].x - lm[0].x) > 0.05; 
            const indexOpen = lm[8].y < lm[6].y;
            const middleOpen = lm[12].y < lm[10].y;
            const ringOpen = lm[16].y < lm[14].y;
            const pinkyOpen = lm[20].y < lm[18].y;

            const count = [indexOpen, middleOpen, ringOpen, pinkyOpen].filter(Boolean).length;

            // 调试：打印手指状态
            // console.log(count, thumbOpen, indexOpen, middleOpen, ringOpen, pinkyOpen);

            if (indexOpen && middleOpen && !ringOpen && !pinkyOpen) return 'victory'; // 剪刀手
            if (count === 4 && thumbOpen) return 'open'; // 张手
            // 握拳判断放宽：所有手指都弯曲 (count === 0) 即可，拇指状态不强制
            if (count === 0) return 'fist'; // 握拳 (修正：不再强制要求拇指弯曲)
            if (indexOpen && !middleOpen && !ringOpen && !pinkyOpen) return 'point'; // 食指
            if (thumbOpen && !indexOpen && !middleOpen && !ringOpen && !pinkyOpen) return 'thumb'; // 大拇指

            return STATE.currentGesture; // 保持上一状态
        }

        function updateTargetShape(gesture) {
            let target;
            switch(gesture) {
                case 'open': target = ShapeCache.sphere; break;
                case 'fist': target = ShapeCache.tree; break;
                case 'victory': target = ShapeCache.text; break;
                case 'point': target = ShapeCache.star; break;
                case 'thumb': target = ShapeCache.heart; break;
                default: target = ShapeCache.sphere;
            }
            if (target && target.pos) {
                 currentTargetPositions = target.pos;
                 // 如果形状没有定义颜色，回退到默认颜色，防止 NaN
                 currentTargetColors = target.col || defaultColorArr;
            }
        }

        // ==========================================
        // 物理循环
        // ==========================================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            
            // 粒子物理更新
            const p = particlesGeometry.attributes.position.array;
            const c = particlesGeometry.attributes.color.array; // 获取颜色数组
            
            // 获取手部影响
            const handSpeed = STATE.handVelocity.length();
            const isStorm = handSpeed > CONFIG.physics.stormThreshold;
            const stormCenter = STATE.handPosition;

            // 爆炸标志
            let explosionForce = 0;
            if (STATE.needsExplosion) {
                explosionForce = CONFIG.physics.explosionForce;
                STATE.needsExplosion = false;
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const idx = i * 3;
                
                // 1. 获取目标位置 (加上手部偏移)
                // 目标位置是：当前形状的本地坐标 * 缩放 + 手部世界坐标
                const tx = currentTargetPositions[idx] * STATE.handScale + STATE.handPosition.x;
                const ty = currentTargetPositions[idx+1] * STATE.handScale + STATE.handPosition.y;
                const tz = currentTargetPositions[idx+2] * STATE.handScale + STATE.handPosition.z;

                // 2. 物理加速度: 弹簧力 (Hooke's Law)
                // ax = (target - current) * springStrength
                const ax = (tx - p[idx]) * CONFIG.physics.ease;
                const ay = (ty - p[idx+1]) * CONFIG.physics.ease;
                const az = (tz - p[idx+2]) * CONFIG.physics.ease;

                // 3. 更新速度
                velocities[idx] += ax;
                velocities[idx+1] += ay;
                velocities[idx+2] += az;

                // 3.1 颜色插值 (平滑过渡)
                const lerpSpeed = 0.05;
                if (!isNaN(currentTargetColors[idx])) {
                     c[idx] += (currentTargetColors[idx] - c[idx]) * lerpSpeed;
                     c[idx+1] += (currentTargetColors[idx+1] - c[idx+1]) * lerpSpeed;
                     c[idx+2] += (currentTargetColors[idx+2] - c[idx+2]) * lerpSpeed;
                }

                // 4. 应用爆炸特效 (瞬间斥力)
                if (explosionForce > 0) {
                    // 随机方向
                    velocities[idx] += (Math.random() - 0.5) * explosionForce * 10;
                    velocities[idx+1] += (Math.random() - 0.5) * explosionForce * 10;
                    velocities[idx+2] += (Math.random() - 0.5) * explosionForce * 10;
                }

                // 5. 应用挥手风暴 (Wave Storm)
                if (isStorm) {
                    // 计算粒子到手的距离
                    const dx = p[idx] - stormCenter.x;
                    const dy = p[idx+1] - stormCenter.y;
                    const dz = p[idx+2] - stormCenter.z;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    
                    if (distSq < 2500) { // 50 units range
                        const force = CONFIG.physics.stormForce * handSpeed / (Math.sqrt(distSq) + 1);
                        // 沿着手速方向施加力
                        velocities[idx] += STATE.handVelocity.x * force * 0.1;
                        velocities[idx+1] += STATE.handVelocity.y * force * 0.1;
                        velocities[idx+2] += STATE.handVelocity.z * force * 0.1;
                    }
                }

                // 6. 摩擦力 (Damping)
                velocities[idx] *= CONFIG.physics.friction;
                velocities[idx+1] *= CONFIG.physics.friction;
                velocities[idx+2] *= CONFIG.physics.friction;

                // 7. 更新位置
                p[idx] += velocities[idx];
                p[idx+1] += velocities[idx+1];
                p[idx+2] += velocities[idx+2];
            }

            particlesGeometry.attributes.position.needsUpdate = true;
            particlesGeometry.attributes.color.needsUpdate = true; // 告诉 Three.js 更新颜色
            
            // 粒子系统整体稍微旋转一点，增加动感
            particleSystem.rotation.y += 0.001;

            renderer.render(scene, camera);
        }

        // ==========================================
        // 初始化 MediaPipe Camera
        // ==========================================
        const hands = new Hands({locateFile: (file) => {
            return `https://unpkg.com/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // 启动
        cameraUtils.start()
            .then(() => {
                console.log("Camera started");
                animate();
            })
            .catch(err => {
                console.error("Camera failed", err);
                document.getElementById('loading').innerHTML = "摄像头启动失败<br>请检查权限或使用 HTTPS";
            });

        // 窗口调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
